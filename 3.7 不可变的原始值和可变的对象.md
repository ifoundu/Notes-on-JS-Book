# 3.7 不可变的原始值和可变的对象

对“不可变” 或 “可变” 的理解，只是需要知道它们在JS中数据类型是怎么被“规范”的。


### 1. 原始值：不可更改的  

字符`像`是由字符组成的数组，指定索引来修改字符串中的字符。

``` javascript
var s = "hello";
var S = s.toUpperCase();
console.log(S)   // -> HELLO
``` 

这是“引用后修改”；JS将其定义为“新建一个新的字符串”，即原始字符串不改。


#### 原始值的比较 

- 数字、布尔值、null、undefined：

  值相等，JS则判断他们相等。  //应该是V8引擎里的JS编译器、执行器判断的。

- 字符串： 引擎判断依据
 
  当且仅当 长度相等 ，且 每个索引的字符 都相等
   
### 2. 对象：

#### (1)  可变、可更改

引用`属性`后修改


#### (2)  但与原对象永不相等

不管属性（名）和值（索引元素）是否都相等。

这样的“永不相等”，就像是两个同卵双胞胎之间的联系。出生时基因一样，但永不能说他们是相同的人。
// 诶...那克隆怎么说...先这样吧...  

在JS里，对象是可变的，因此在程序中间可能被修改；  
修改后的对象在被比较时，如果要判断“是否相等”，就要在程序中从头到尾检查是否被修改了；  
有修改则需要将每次修改都做对比。  
如此程序会很难做判断，“负担”很大。  
因此，干脆在“环境”中做到“规定”它们之间——没有相等这回事。  

这个思路，
就可以由文中关于“引用”的描述来证明:  
    
> 对象的值就是‘引用’，对象的比较均是“引用的比较”：当且仅当它们引用同一个基对象是，它们才相等。

“引用的比较”、“同一个基对象”，也就是说拿来比较的基础，是同一个对象。同一个对象就只拿最后的结果比较，  
不需要进行“从头到尾”的检查和对比。  

虽然“引用的比较”的描述并非证明以上思路的充分条件，但是可否算必要条件？还得之后继续确认。


``` javascript
// 数组的复制：显式复制对象的每个属性或数组的每个元素 （为了进行数组相等比较的前提准备）
var a = ['a','b','c'];
var b = [];
for(var i = 0;i < a.length;i++ ) {
  b[i] = a[i];
}

// 数值的比较：其他对象类似——必须比较它们的属性或元素
function equalArrays(a,b) {
  if (a.length != b.length) 
  return false; 
  for(var i = 0;i < a.length; i++)
    if (a[i] !== b[i]) 
    return false;
  return true;

}

console.log(b) 
```



